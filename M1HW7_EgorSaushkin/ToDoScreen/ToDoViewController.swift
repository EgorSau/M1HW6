//
//  ToDoViewController.swift
//  M1HW7_EgorSaushkin
//
//  Created by Egor SAUSHKIN on 22.02.2023.
//  Copyright (c) 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ToDoDisplayLogic: AnyObject {
	func display(viewModel: ToDo.Model.ViewModel)
}

/// Контроллер для отображения списка задач
class ViewController: UIViewController, ToDoDisplayLogic {
	
	private enum CellType: String {
		case important = "ImportantTableCell"
		case regular = "RegularTableCell"
	}
	
	var interactor: ToDoBusinessLogic?
	var router: (NSObjectProtocol & ToDoRoutingLogic & ToDoDataPassing)?
	private let padding: CGFloat = 16
	private var titles: ((String) -> Void)?
	private var rows: ((Int) -> Void)?
	private var tasks: (([Task]) -> Void)?

	private lazy var tableView: UITableView = {
		let table = UITableView(frame: CGRect.zero, style: .grouped)
		table.delegate = self
		table.dataSource = self
		table.backgroundColor = .white
		table.register(ImportantTableCell.self, forCellReuseIdentifier: CellType.important.rawValue)
		table.register(RegularTableCell.self, forCellReuseIdentifier: CellType.regular.rawValue)
		table.translatesAutoresizingMaskIntoConstraints = false
		table.rowHeight = 40
		return table
	}()
	
	// MARK: Object lifecycle
	
	override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
		super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
		setup()
	}
	
	required init?(coder aDecoder: NSCoder) {
		super.init(coder: aDecoder)
		setup()
	}
	
	// MARK: Setup
	
	private func setupConstraints() {
		view.backgroundColor = .white
		view.addSubview(tableView)
		
		NSLayoutConstraint.activate([
			tableView.topAnchor.constraint(equalTo: view.topAnchor, constant: padding),
			tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: padding),
			tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -padding),
			tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -padding)
		])
	}
	
	private func setup() {
		let viewController = self
		let interactor = ToDoInteractor()
		let presenter = ToDoPresenter()
		let router = ToDoRouter()
		viewController.interactor = interactor
		viewController.router = router
		interactor.presenter = presenter
		presenter.viewController = viewController
		router.viewController = viewController
		router.dataStore = interactor
	}
	
	// MARK: Routing
	
	override func prepare(for segue: UIStoryboardSegue, sender: Any?)
	{
		if let scene = segue.identifier {
			let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
			if let router = router, router.responds(to: selector) {
				router.perform(selector, with: segue)
			}
		}
	}
	
	// MARK: View lifecycle
	
	override func viewDidLoad() {
		super.viewDidLoad()
		setupConstraints()
	}
	
	// MARK: Methods
	
	func makeRequest(for section: Int) {
		let request = ToDo.Model.Request(section: section)
		interactor?.prepareTableWithTasks(request: request)
	}
	
	func display(viewModel: ToDo.Model.ViewModel) {
		titles?(viewModel.title)
		rows?(viewModel.numberOfRows)
		tasks?(viewModel.tasks)
	}
}

extension ViewController: UITableViewDelegate, UITableViewDataSource {
	
	func numberOfSections(in tableView: UITableView) -> Int {
		let numberOfSections: Int = 2
		makeRequest(for: numberOfSections)
		return numberOfSections
	}
	
	func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
		var titleForSection: String = ""
		titles = { title in
			titleForSection = title
		}
		return titleForSection
	}
	
	func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		var rowsForSection: Int = 0
		rows = { row in
			rowsForSection = row
		}
		return rowsForSection
	}
	
	func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		var taskForCell = Task(title: "")
		tasks = { task in
			taskForCell = task[indexPath.row]
		}
		var cell = UITableViewCell()
		
		switch taskForCell {
		case is ImportantTask:
			guard let importantCell = tableView.dequeueReusableCell(withIdentifier: CellType.important.rawValue) as? ImportantTableCell else { return cell }
			cell = importantCell
			importantCell.setupCell(withViewModel: taskForCell)
		default:
			guard let regularCell = tableView.dequeueReusableCell(withIdentifier: CellType.regular.rawValue) as? RegularTableCell else { return cell }
			cell = regularCell
			regularCell.setupCell(withViewModel: taskForCell)
		}
		return cell
	}
	
	func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
		var taskForCell = Task(title: "")
		tasks = { task in
			taskForCell = task[indexPath.row]
		}
		taskForCell.completed.toggle()
		tableView.reloadData()
	}
}
